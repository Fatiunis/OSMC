services:
  mysql:
    image: mysql:8.0
    container_name: mysql_${ENV_NAME}
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: hospital_${ENV_NAME} # DB única por ambiente
    ports:
      - "${DB_PORT}:3306" # Dev: 3306, UAT: 3307, Prod: 3308
    volumes:
      # Usamos el nombre del ambiente para que los datos no se mezclen
      - db_data_${ENV_NAME}:/var/lib/mysql
    networks:
      - hospital_net

      

  backend:
    build: ./sistema_adfs
    container_name: backend_${ENV_NAME}
    ports:
      - "${BE_PORT}:80" # Dev: 8080, UAT: 8081, Prod: 80
    environment:
      DB_HOST: mysql
      DB_NAME: hospital_${ENV_NAME}
      DB_USER: root
      DB_PASS: rootpassword
    depends_on:
      - mysql
    volumes:
      - ./sistema_adfs:/var/www/html  # Sincroniza código del backend
    networks:
      - hospital_net

  frontend:
    build: ./HOSPITAL_SYSTEM_REACT
    container_name: frontend_${ENV_NAME}
    ports:
      - "${FE_PORT}:5173" # Dev: 5173, UAT: 5174, Prod: 3000
    # El host 0.0.0.0 es vital para que responda fuera del contenedor
    command: sh -c "npm install && npm run dev -- --host 0.0.0.0"
    environment:
      - VITE_API_URL=http://localhost:${BE_PORT}
    volumes:
      - ./HOSPITAL_SYSTEM_REACT:/app # Sincroniza tu código local con /app
      - /app/node_modules           # Protege los módulos instalados en el contenedor
    networks:
      - hospital_net


networks:
  # Red para que los contenedores se hablen entre sí por nombre de servicio
  # Docker le pondrá el nombre automáticamente: proyecto_hospital_net
   hospital_net:
    driver: bridge


volumes:
  # Definimos los volúmenes para que Docker los cree según el ambiente
  db_data_dev:
  db_data_uat:
  db_data_prod: